# 프론트엔드 미션 트랙 2주차

---

## HTTP & 네트워크 기본 개념 정립

* 클라이언트의 요청과 서버의 응답으로 이루어지는 웹 통신의 기본 구조인 HTTP 통신 구조를 학습했습니다.
* `GET`(조회)과 `POST`(생성)의 차이를 명확히 하고 상황에 맞는 메서드 사용의 중요성을 이해했습니다.
* `200`(성공), `404`(찾을 수 없음), `500`(서버 오류) 등 주요 상태 코드를 통해 통신 결과를 파악하는 법을 익혔습니다.
* www.google.com을 입력했을 때 DNS를 통해 IP를 찾고, TCP/IP 연결을 거쳐 화면이 그려지는 브라우저 렌더링 원리를 정리했습니다.

---

## Hook의 기본 개념 정립

* **`useState`**: 일반 변수(`let`)는 값이 변해도 화면이 갱신되지 않지만, State는 변경 시 리렌더링이 발생해 UI를 업데이트한다는 차이점을 이해했습니다.
* **`useEffect`**: 컴포넌트 생명주기에 맞춰 특정 시점(마운트 시, 특정 값 변경 시)에 코드를 실행하는 방법을 학습했습니다. 의존성 배열의 유무에 따른 동작 차이도 학습했습니다.
* **`useNavigate`**: 페이지 이동 시 `replace` 옵션이나 `state` 객체를 통해 데이터를 은밀하게 전달하는 고급 사용법을 학습했습니다.

---

## 개발 환경 난관 및 해결 과정

* `border border-gray-500`이나 `text-gray-500` 명령어가 정상적으로 실행되지 않는 오류가 계속 생겨 Tailwind CSS 기반으로 디자인하는게 너무 힘들었습니다.
* 저번에 분명히 해결했다고 생각했는데 이제는 부분적으로 인식하지 못하는 버그가 발생하여 Gemini를 며칠간 붙들고 해결하려해보았습니다.
* 계속 해결하지 못하다가 최근에 Gemini 3버전이 나와서 문제점에 대해 이야기해보니 `postcss.config.js`파일의 내용을 수정하고 안정적인 버전으로 Tailwind CSS를 다운그레이드시키니 정상적으로 명령어가 실행되었습니다.

---

## 쇼핑몰 기능 구현

* 1주차에 만든 UI에 기능을 입히고 컴포넌트 구조를 체계적으로 개편했습니다.

### 컴포넌트 재사용성 활용

* **`Cart` 컴포넌트**
    * 처음에는 페이지마다 상품 목록 리스트를 따로 구현하려 했으나, `ProductCard`와 리스트 출력 로직을 `Cart.jsx` 하나로 통합하였습니다.
    * `Home`, `Category`, `Price` 페이지에서는 데이터를 가공해서 `items` props로 넘겨주기만 하면 화면이 그려지도록 설계하여 코드 중복을 획기적으로 줄였습니다.

---

## 2주차 미션 후기
* 단순히 화면을 그리는 것을 넘어서 데이터를 어떻게 효율적으로 관리할 지와 컴포넌트를 어떻게 재사용할 지에 대해 깊게 고민해보았습니다.
* 데이터가 계속 꼬여서 막막했지만 원본 데이터를 하나로 통일하고 로직으로 풀어내는 정석적인 방법을 통해 React의 동작 원리를 더 깊이 이해하게 되었습니다.
* 이번 주차에도 여러 문제를 겪으며 쇼핑몰 구현에 많은 시간이 들어가게 되었는데 그만큼 개인적으로 만족스러운 결과물이 나와서 좋아습니다.