# npm vs pnpm 비교

## npm (Node Package Manager)

`npm`은 호이스팅(hoisting)이라는 기법을 이용해 모든 하위 의존성 패키지들을 `node_modules`의 최상단으로 끌어올려 평평한 구조로 만듭니다.

### 작동 방식
* `A` 패키지를 설치하면 `node_modules/A`에 복사됩니다.
* `A`가 의존하는 `B` 패키지도 `node_modules/B`에 복사됩니다.
* 다른 프로젝트에서도 `A`와 `B`를 쓴다면, 그 프로젝트의 `node_modules` 폴더에도 `A`와 `B`가 똑같이 복사됩니다.
* `node_modules` 구조는 모든 패키지가 최상단에 나열되어 거대하고 평평해집니다.

### 문제점

**1. 유령 의존성 (Phantom Dependencies) 문제**
* **가정**: 내 프로젝트가 `A`, `B`를 의존하고, `A`와 `B` 둘 다 `C`를 의존합니다.
* **동작**: `npm`은 호이스팅을 통해 `C` 패키지를 `node_modules` 최상단에 한 번만 설치합니다. (디스크 용량 최적화를 위해)
* **문제**: `package.json`에 `C`를 명시하지 않았는데도, 개발자가 `import C from 'c';` 코드로 `C`를 임의로 가져다 쓸 수 있게 됩니다.
* **오류**: `A`와 `B`가 필요 없어져 제거하면, `C`도 함께 삭제됩니다. 이로 인해 `import C from 'c';` 코드는 오류를 발생시킵니다.

**2. 디스크 공간 낭비 (프로젝트 간 중복)**
* `npm`은 프로젝트별로 `node_modules` 폴더를 따로 관리하며 파일을 그대로 복사합니다.
* `프로젝트A`가 `react@17`을 설치하고, `프로젝트B`도 `react@17`을 설치하면, 컴퓨터에는 `react@17` 파일이 중복으로 저장되어 디스크 공간을 낭비

---

## pnpm (Performant npm)

`pnpm`은 `npm`의 비효율을 해결하기 위해 심볼릭 링크(Symbolic Link, 바로가기)와 콘텐츠 주소 지정 저장소(CAS) 방식을 사용합니다.

### 작동 방식
* 패키지를 설치하면, 해당 패키지는 PC 내 단 하나의 전역 저장소(`~/.pnpm-store` 같은 곳)에 저장됩니다. (단 한 번만)
* 프로젝트의 `node_modules` 폴더에는 실제 파일이 복사되는 대신에 이 전역 저장소에 있는 패키지를 가리키는 심볼릭 링크가 생성됩니다.
* `node_modules` 최상단에는 `package.json`에 명시된 패키지들의 심볼릭 링크만 존재합니다.
* 모든 간접 의존성은 `node_modules/.pnpm` 폴더 내부에 격리되어 심볼릭 링크로 구성됩니다.

### 유령 의존성 해결
* Node.js가 `node_modules`를 찾아봤을 때, `package.json`에 명시된 `A`, `B`의 심볼릭 링크만 보입니다.
* 간접 의존성인 `C`는 최상단에 노출되지 않기 때문에 개발자가 `import C from 'c';`를 시도하면 "모듈을 찾을 수 없음" 오류가 발생합니다.
* 이를 통해 `package.json`에 명시하지 않은 패키지의 참조를 제한할 수 있습니다.

---

## 차이점

| 특징 | npm (v3+) | pnpm |
| :--- | :--- | :--- |
| **`node_modules` 구조** | 평면 구조 | 비평면 구조 + 심볼릭 링크 |
| **디스크 공간** | 비효율적 (프로젝트마다 중복 저장) | 효율적 (전역 저장소에 1번만 저장) |
| **유령 의존성** | 발생 가능 (호이스팅) | 불가능 (심볼릭 링크로 격리) |

---

## 결론

* 초기 설정은 `npm`이 더 익숙하고 간편할 수 있습니다.
* 하지만 `pnpm`은 `npm`에 비해 압도적인 디스크 공간 효율성과 유령 의존성 방지라는 강력한 장점을 가집니다.
* 저라면 장기적으로 훨씬 유리한 **`pnpm`**을 선택하여 효율적인 개발 환경을 구성할 것 같습니다.