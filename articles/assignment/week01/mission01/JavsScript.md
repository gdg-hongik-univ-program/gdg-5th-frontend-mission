# JavaScript의 기초

---

## 자바스크립트의 역사와 특징

### 탄생과 표준화
* 1995년 넷스케이프(Netscape)의 브렌던 아이크(Brendan Eich)가 HTML을 동적으로 표현하기 위해 개발했습니다.
* 마이크로소프트가 JScript라는 파생 버전을 출시하면서 크로스 브라우징 이슈가 발생했습니다.
* 파편화를 막기 위해 1997년 ECMA-262가 ECMAScript라는 표준 명세로 제정되었습니다.

### 성장 과정
* **Ajax (1999)**: 서버와 비동기적으로 데이터를 교환하는 통신 기술로 전체 페이지를 새로고침하는 비효율을 해결하여 부분 렌더링을 가능하게 했습니다.
* **V8 자바스크립트 엔진 (2008)**: 구글이 발표한 고성능 엔진으로 자바스크립트의 실행 속도를 획기적으로 개선하여 복잡한 SPA개발을 가능하게 했습니다.
* **Node.js (2009)**: Chrome V8 엔진으로 빌드된 런타임 환경으로 자바스크립트를 웹 브라우저 외부에서 실행할 수 있게 하여 자바스크립트를 범용 프로그래밍 언어로 확장시켰습니다.

### 언어의 특징
* **유일한 클라이언트 언어**: HTML, CSS와 함께 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다.
* **인터프리터 언어**: 별도의 컴파일 과정 없이 소스코드를 즉시 실행하는 인터프리터 언어이지만, 현대 엔진은 컴파일러의 장점을 결합한 JIT 컴파일 방식을 사용합니다.
* **멀티 패러다임**: 명령형, 함수형, 프로토타입 기반 객체지향 등 여러 패러다임을 지원합니다.

---

## 자바스크립트 개발 환경과 실행

### 웹 브라우저
* **개발자 도구**: 자바스크립트 개발에 필수적인 도구입니다. (`F12`로 오픈)
    * **Console**: 자바스크립트 코드 실행 및 에러, `console.log` 출력 결과를 확인하는 REPL 환경으로도 사용됩니다.
    * **Sources**: 자바스크립트 코드를 디버깅할 수 있습니다.
* **클라이언트 코드 실행**: `alert()`과 같이 클라이언트 사이드 Web API가 포함된 자바스크립트는 Node.js 환경이 아닌 브라우저 환경에서 실행해야 합니다.

### Node.js 환경
* 웹 브라우저 환경이 아닌 곳(서버 사이드, 프런트엔드 도구)에서 자바스크립트를 실행하는 런타임 환경입니다.
* **npm**: Node.js 환경에서 사용할 수 있는 모듈을 저장하고 설치/관리하는 패키지 매니저가 함께 제공됩니다.
* **REPL 환경**: 터미널에서 `node` 명령어 입력 시 Node.js REPL 환경으로 진입하여 간단한 코드를 테스트할 수 있습니다.

### VS Code 활용
* VS Code에 내장된 터미널을 통해 `node index.js` 명령어로 자바스크립트 파일을 실행할 수 있습니다.
* **Code Runner**: VS Code 내에서 코드를 쉽게 실행하는 데 도움을 줍니다.
* **Live Server**: HTML/JS 파일에 가상 서버를 띄우고, 코드를 수정할 때마다 브라우저에 자동으로 반영해 주는 기능을 제공합니다.

---

## 브라우저 렌더링 및 실행 원리

### 렌더링 과정
* **요청/응답**: 브라우저는 서버에 요청하여 HTML, CSS, JS 등의 파일을 응답받습니다.
* **파싱**: HTML 파일은 `DOM(Document Object Model)` 트리로, CSS 파일은 `CSSOM(CSS Object Model)` 트리로 변환됩니다.
* **렌더 트리**: `DOM` 트리와 `CSSOM` 트리가 결합되어 Render Tree가 생성되고, 이를 기반으로 웹페이지를 화면에 표시합니다.

### 자바스크립트 실행의 특징
* **동기적 처리**: 브라우저는 `HTML`, `CSS`, `JavaScript`를 동기적으로 처리합니다.
* **블로킹**: 파서가 `<script>`태그를 만나면 DOM 생성을 중단하고 제어권을 자바스크립트 엔진에 넘깁니다. (스크립트 실행이 완료된 후에 DOM 생성 재개)

### `<script>` 태그의 위치
* `<script>` 태그는 `<body>` 요소의 가장 아래에 위치시키는 것이 좋습니다.
* **이유**
    1. 스크립트 로딩으로 인한 HTML 렌더링 지연을 방지하여 페이지 로딩 시간을 단축합니다.
    2. 자바스크립트가 DOM이 완성된 상태에서 DOM 조작을 수행하도록 보장하여 오류를 방지합니다.

---

## 자바스크립트 언어의 기본 요소

### 변수, 값, 키워드
* **변수 (Variable)**: 값의 위치(메모리 주소)를 기억하고, 값에 의미를 부여하는 식별자입니다.
* **값 (Value)**: Literal 표기법을 사용하여 생성하는, 프로그램이 조작할 수 있는 대상입니다.
* **연산자 (Operator)**: 피연산자를 대상으로 산술, 할당, 비교 등의 연산을 수행하여 값을 만듭니다.
* **키워드 (Keyword)**: `var`, `function`처럼 자바스크립트 엔진이 수행할 동작을 규정한 예약어입니다.
* **주석 (Comment)**: 코드의 의미를 설명하며, 파서가 무시하고 실행되지 않습니다.

### 문(Statement)과 표현식(Expression)
* **표현식**: 평가(Evaluation)되어 하나의 값을 만들어내는 코드의 조합입니다.
* **문**: 자바스크립트 엔진에게 내리는 명령입니다. (예: `변수 선언, 할당, 조건문 실행`)
* **역할 구분**: 표현식은 값을 생성하고, 문은 그 값을 사용해 컴퓨터에게 명령을 내립니다.

### 함수, 객체, 배열
* **함수 (Function)**: 특정 작업을 수행하는 문들의 집합으로 코드 재사용성을 위해 사용됩니다.
* **객체 (Object)**: 데이터와 동작을 통합한 독립적인 실체이며 프로토타입을 통해 상속을 구현합니다.
* **배열 (Array)**: 여러 개의 값을 순차적으로 저장하는 특수한 형태의 객체입니다.

---

## 데이터 타입과 변수

### 타입의 분류와 특징
* **정적 vs 동적 타입**: C, Java는 정적 타입으로 타입을 선언해야 하지만, 자바스크립트는 동적 타입 언어로 런타임에 값이 할당될 때 타입이 결정됩니다.
* **원시 vs 객체 타입**: 자바스크립트의 7개 데이터 타입은 원시 타입과 객체 타입으로 나뉩니다.

### 원시 타입 상세
* **`number`**: 정수/실수 구분이 없는 단일 숫자 타입이며 모든 수는 64비트 부동소수점 형식으로 저장됩니다. (`Infinity`, `NaN`도 포함)
* **`string`**: 텍스트 데이터를 나타내며, 생성 후 변경이 불가능한 불변 값입니다.
* **`undefined`**: 변수가 선언되었으나 값이 할당되지 않은 상태의 초기값으로 자바스크립트 엔진이 할당합니다.
* **`null`**: 개발자가 의도적으로 값이 없음을 명시할 때 사용됩니다.

### `var` 키워드의 문제점
* **호이스팅 (Hoisting)**: `var` 선언은 스코프의 선두로 끌어올려지며 선언 전에 접근해도 `ReferenceError` 대신 `undefined`가 반환됩니다.
* **함수 레벨 스코프**: `var`는 `if`, `for`와 같은 블록 스코프를 무시하고 함수 내부 전체를 범위로 가집니다.
* 위 두 특징 때문에 중복 선언 허용과 전역 변수 남용을 유발하여 코드의 복잡성과 부수 효과(Side Effect)가 증가합니다.

---

## 표현식, 문, 연산자

### 산술 및 할당 연산자
* **부수 효과**: 이항 산술 연산자는 부수 효과가 없지만, 할당 연산자와 단항 증/감소 연산자는 좌항 변수의 값을 변경하므로 부수 효과가 있습니다.
* **중첩 할당**: 할당문은 표현식이므로 `var foo = x = 100;`처럼 중첩하여 사용할 수 있습니다.

### 비교 연산자
* **동등 비교 (`==`)**: 암묵적 타입 변환을 통해 값을 비교하여 수많은 부작용을 일으키므로 사용하지 않는 것이 권장됩니다.
* **일치 비교 (`===`)**: 값과 타입이 모두 같을 경우에만 `true`를 반환하는 엄격한 비교입니다.
* **`NaN` 예외**: `NaN`은 자신과 일치하지 않는 유일한 값이므로 (`NaN === NaN`은 `false`), `isNaN()` 함수로 확인해야 합니다.

### 논리 및 기타 연산자
* **삼항 조건 연산자 (`? :`)**: 자바스크립트의 유일한 삼항 연산자이며 표현식으로 평가되어 조건에 따른 값 할당에 유용합니다.
* **`||`, `&&`**: 논리 연산자는 항상 boolean을 반환하지 않고, 연산 결과를 결정한 피연산자의 값을 그대로 반환하는 단축 평가 특징을 가집니다.
* **`typeof` 연산자**: 피연산자의 타입을 문자열로 반환하나, `typeof null`이 `'object'`로 나오는 설계상 오류가 있습니다.
* **쉼표 연산자 (`,`)**: 왼쪽부터 차례대로 평가하고 가장 마지막 피연산자의 평가 결과를 반환합니다.

---

## 흐름 제어

### 블록문과 조건문
* **블록문**: 중괄호 `{ }`로 묶인 명령의 집합입니다. (끝에 세미콜론 불필요)
* **조건문**: `if else` 문과 `switch` 문이 있습니다. (`switch` 문은 일치하는 `case`를 찾더라도 `break`가 없으면 다음 `case`까지 코드가 연속 실행)

### 반복문
* **`for` 문**: 초기화식, 조건식, 증감식이 모두 옵션입니다. (초기화식은 단 한 번만 실행)
* **`do...while` 문**: 조건식 평가 이전에 코드 블록을 최소한 한 번 이상 실행합니다.

### 흐름 제어 구문
* **`break`**: `switch`, 반복문, 레이블 문 등 코드 블록을 즉시 탈출시킵니다.
* **`continue`**: 반복문을 탈출하지 않고, 현재 사이클 실행을 중단한 후 다음 반복으로 이동합니다.
* **레이블 문**: 식별자가 붙은 문으로 `break`에 레이블을 지정하여 중첩된 반복문의 외부까지 탈출하는 데 사용될 수 있습니다.

---

## 타입 변환

### 명시적 vs. 암묵적 변환
* **명시적 변환**: 개발자가 `Number()`, `.toString()`, `Boolean()` 등의 함수를 사용하여 의도적으로 타입을 변경합니다.
* **암묵적 변환**: 자바스크립트 엔진이 연산의 문맥(Context)에 맞추기 위해 자동으로 타입을 변경하는 것입니다.

### 암묵적 변환의 상세 규칙
* **Falsy 값**: 조건문 문맥에서 `false`로 간주되는 7가지 값(`false`, `undefined`, `null` 등)을 제외한 모든 값은 `true`로 변환됩니다.
* **숫자 변환**: 산술 연산자나 비교 연산자 문맥에서 발생하며, `null`과 `""`는 `0`으로, `undefined`는 `NaN`으로 변환됩니다.
* **문자열 변환**: `+` 연산자가 문자열과 함께 사용될 때 모든 피연산자를 문자열로 변환합니다.

### 단축 평가
* **`&&` (AND)**: 첫 번째 피연산자가 Falsy이면 뒤를 평가하지 않고 첫 번째 값을 반환합니다. (예: `elem && elem.value`로 `TypeError` 방지)
* **`||` (OR)**: 첫 번째 피연산자가 Truthy이면 뒤를 평가하지 않고 첫 번째 값을 반환합니다. (예: 기본값 설정)

---

## 객체와 메모리 모델

### 객체의 구조와 생성
* **객체**: 데이터(프로퍼티)와 동작을 통합한 독립적인 실체입니다.
* **생성**: 가장 일반적인 방식은 객체 리터럴(`{ }`)이며 ES6의 `class`는 기존 프로토타입 패턴을 쉽게 작성하기 위한 `문법적 설탕`입니다.
* **생성자 함수 (Custom)**: `function Person() {}`과 같이 정의하여 사용하며 `this`에 바인딩된 데이터는 `public` 속성을 가집니다.

### 프로퍼티 접근
* **마침표 표기법 (`.`)**: 프로퍼티 키가 유효한 식별자일 때 사용합니다.
* **대괄호 표기법 (`[]`)**: 대괄호 안의 키는 반드시 문자열이어야 하며, 유효하지 않은 식별자(`first-name` 등)에 접근할 때 사용합니다.

### 10.3. 데이터 전달 방식
* **원시 타입**: 값에 의한 전달 방식으로 값이 복사됩니다.
* **객체 타입**: 참조에 의한 전달 방식으로 객체의 주소만 복사됩니다. (함수 내에서 객체를 변경하면 원본 객체도 변경되는 부수 효과 발생)

### 10.4. 객체 순회
* **`for-in` 문**: 객체의 프로퍼티 키를 순회하는 데 사용됩니다. (배열에는 순서를 보장하지 않고 요소 외의 프로퍼티도 순회하기에 사용하지 않는 것을 권장)

---

## 불변성과 데이터 패턴

### 불변 값 vs. 가변 값
* **원시 타입**: 불변 값 (값을 재할당하는 것은 새로운 값을 생성하는 것)
* **객체 타입**: 가변 값 (프로퍼티를 직접 변경 가능)

### 11.2. 불변 데이터 패턴 구현
* **필요성**: 객체의 가변성이 버그의 원인이 되므로 불변 데이터 패턴을 통해 원본 수정을 방지합니다.
* **`Object.assign`**: 객체를 복사하여 새로운 객체를 만들지만, 중첩된 객체는 얕은 복사가 되어 원본과 참조를 공유하는 문제가 있습니다.
* **`Object.freeze`**: 객체의 프로퍼티 변경을 막지만 얕은 동결만 수행합니다. (내부 객체까지 막으려면 Deep freeze를 구현해야 함)

---

## 함수 심화

### 함수 정의 방식과 호이스팅
* **함수 선언문**: 호이스팅되어 코드 내 어느 위치에서든 호출 가능합니다.
* **함수 표현식**: 함수 자체가 아닌 변수만 호이스팅되므로 할당문 이전에 호출하면 `TypeError`가 발생합니다.

### 함수 객체의 특성
* **일급 객체**: 함수는 일급 객체이므로 변수에 할당, 인수로 전달, 반환값으로 사용 등 제약 없이 사용됩니다.
* **`arguments`**: 함수 호출 시 전달된 인수의 정보를 담고 있는 유사 배열 객체입니다. (가변 인자 함수 구현에 유용)

### 인수의 전달과 부수 효과
* **순수 함수 (Pure Function)**: 외부 상태를 변경하지 않아 예측 가능하고 디버깅이 쉽습니다.
* **비순수 함수 (Impure Function)**: 객체 타입 인수를 받아 내부에서 변경하여 외부 객체를 오염시키는 등 부수 효과를 발생시킵니다.

### 함수 패턴
* **즉시 실행 함수 (IIFE)**: 정의와 동시에 실행되어 전역 변수 오염을 막고 초기화 로직을 실행하는 데 사용됩니다.
* **콜백 함수**: 다른 함수에 인수로 전달되어 특정 시점에 시스템에 의해 호출되는 함수입니다.
* **재귀 함수**: 자기 자신을 호출하는 함수로 탈출 조건이 반드시 필요합니다.

---

## 타입 체크와 유사 배열 객체

### 타입 체크 수단과 한계
* **`typeof`**: `null`에 대해 `'object'`를 반환하는 등의 한계가 있어 객체의 종류를 세분화하여 구분하는 데는 부적합합니다.
* **`Object.prototype.toString`**: `call` 메소드를 사용해 모든 값의 내부 타입을 정확하게 식별할 수 있습니다. (가장 정확한 타입 체크 방법)
* **`Array.isArray`**: 객체가 실제 배열인지 확인하기 위해 사용합니다.

### 유사 배열 객체
* `length` 프로퍼티를 가진 객체(문자열, `arguments` 등)는 순회는 가능하나 실제 배열이 아니므로 배열 메소드를 직접 사용할 수 없습니다.

---

## 프로토타입과 상속

### 프로토타입 체인
* **프로토타입**: 자바스크립트 객체의 부모 역할을 담당하며 프로퍼티와 메소드를 상속받습니다.
* **`[[Prototype]]`, `prototype`**: `[[Prototype]]`은 모든 객체가 가지는 상속 링크이며 `prototype`은 함수 객체만이 소유 (자식 객체의 부모를 지정)
* **프로토타입 체인**: 객체에 없는 프로퍼티에 접근 시 `[[Prototype]]` 링크를 따라 상위 부모 객체를 차례대로 검색하는 메커니즘입니다.

### 프로토타입의 동적 관리
* **확장**: 프로토타입 객체는 런타임에 프로퍼티나 메소드를 추가/삭제할 수 있으며 이는 즉시 모든 인스턴스에 반영됩니다.
* **동적 변경**: 생성자 함수의 `prototype`이 가리키는 객체 자체를 다른 객체로 변경할 수 있습니다.
* **쓰기(할당)**: 프로퍼티에 값을 할당할 때는 체인이 동작하지 않습니다. (객체에 프로퍼티가 없으면 해당 객체에 새로운 프로퍼티를 동적 추가)

### 원시 타입의 확장
* 객체는 아니지만, `toUpperCase()` 같은 메소드를 호출할 때 잠깐 Wrapper Object로 변환되어 프로토타입을 통해 메소드를 사용할 수 있습니다.

---

## 스코프와 전역 변수 관리

### 15.1. 스코프의 기본 원칙
* **정의**: 식별자(변수, 함수)의 유효 범위를 결정하는 규칙입니다.
* **스코프 구분**: 전역 스코프(코드 어디에서든 참조 가능)와 지역 스코프(함수 내부에서만 참조 가능)로 나뉩니다.
* **렉시컬 스코프**: 함수가 어디서 선언되었는지에 따라 상위 스코프가 결정됩니다.

### `var`의 문제점과 전역 변수 오염
* **비 블록 레벨 스코프**: `var`는 `{ }` 블록을 무시하고 함수 레벨 스코프를 따릅니다.
* **암묵적 전역**: `var`, `let`, `const` 없이 선언되지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티로 해석되어 전역 변수처럼 동작합니다.
* 이는 변수 충돌 및 의도치 않은 상태 변화를 유발하여 코드 예측을 어렵게 합니다.

### 전역 변수 오염 방지 방법
* **네임스페이스 패턴**: `var MYAPP = {};`처럼 하나의 전역 객체만 만들고 모든 변수와 함수를 그 객체의 프로퍼티로 연결합니다.
* **즉시 실행 함수**: 로직을 지역 스코프에 가두고 실행하여 전역 변수 생성을 억제합니다.